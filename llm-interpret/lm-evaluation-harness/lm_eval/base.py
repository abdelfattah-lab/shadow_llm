import abc
from typing import Iterable
import numpy as np
import random
import re
import os
import json
import hashlib
import datasets
from sqlitedict import SqliteDict
from tqdm import tqdm
import torch.nn as nn
import torch
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
from lm_eval.metrics import mean, weighted_perplexity, weighted_mean, bits_per_byte
from lm_eval import utils
from abc import abstractmethod
from einops import rearrange
from tqdm import tqdm
from collections import defaultdict
import pickle
import optuna
from functools import partial


from deap import base, creator, tools, algorithms
import random
from deap import tools

fc_metric_calc = True

class SequenceModel(nn.Module):
    def __init__(self, embedding_dim=1024, output_dim=16):
        super(SequenceModel, self).__init__()
        
        # Self-attention layer
        self.self_attention = nn.MultiheadAttention(embed_dim=embedding_dim, num_heads=1, batch_first=True)
        
        # 2-layer MLP
        self.fc1 = nn.Linear(embedding_dim, embedding_dim//4)
        self.fc2 = nn.Linear(embedding_dim//4, output_dim)
    
    def generate_attention_mask(self, input_seq):
        # Assuming padding value is 0, create a mask for non-padded values
        mask = input_seq.ne(0).float()
        # Expand mask for the attention heads
        mask = mask.unsqueeze(1).unsqueeze(1)
        # Convert to boolean (optional, depending on the PyTorch version)
        return mask.bool() if hasattr(mask, 'bool') else mask

    def forward(self, x):
        # Self-attention: [L, E] -> [L, L, E]
        # x, _ = self.self_attention(x, x, x)
        # attention_mask = self.generate_attention_mask(x)
        x, _ = self.self_attention(x, x, x)

        # Aggregating to [1, E]
        x = x.mean(dim=1, keepdim=True)
        
        # Passing through 2-layer MLP
        x = F.relu(self.fc1(x.squeeze(1)))
        x = self.fc2(x)
        
        return x

class LM(abc.ABC):
    def __init__(self):
        self.cache_hook = CacheHook(None)

    @abstractmethod
    def loglikelihood(self, requests):
        """Compute log-likelihood of generating a continuation from a context.
        Downstream tasks should attempt to use loglikelihood instead of other
        LM calls whenever possible.

        :param requests: list
            A list of pairs (context, continuation)
            context: str
                Context string. Implementations of LM must be able to handle an
                empty context string.
            continuation: str
                The continuation over which log likelihood will be calculated. If
                there is a word boundary, the space should be in the continuation.
                For example, context="hello" continuation=" world" is correct.
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    @abstractmethod
    def loglikelihood_rolling(self, requests):
        """Compute full log-likelihood of a string, with no truncation, for perplexity computation
        - We will use the full max context length of the model.
        - For inputs that exceed the max context length, we divide the tokenized string into chunks of up to
        the max context length.
        - IMPORTANT: Each document's loglikelihood/perplexity is computed *separately*, unlike other implementations
          which may simply concatenate multiple documents together.
        - IMPORTANT: We maximize the amount of context for each prediction. Specifically, for inputs that we break into
          multiple chunks, the last input will still a full-sized context.
          Example:
            Input tokens: [ 0 1 2 3 4 5 6 7 8 9 ]
            Prefix: EOT
            Max context length: 4
            Resulting input/prediction pairs:

                INPUT:  EOT   0   1   2
                PRED:     0   1   2   3

                INPUT:    3   4   5   6
                PRED:     4   5   6   7

                INPUT:    5   6   7   8
                PRED:             8   9

          Observe that:
            1. Each token is predicted exactly once
            2. For the last pair, we provide the full context, but only score the last two tokens

        :param requests: list
            A list of strings
            string: str
                String for which we are computing per-toke  loglikelihood
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    # TODO: Add an optional max length
    @abstractmethod
    def greedy_until(self, requests):
        """Generate greedily until a stopping sequence

        :param requests: list
            A list of pairs (context, until)
            context: str
                Context string
            until: [str]
                The string sequences to generate until. These string sequences
                may each span across multiple tokens, or may be part of one token.
        :return: list
            A list of strings continuation
            continuation: str
                The generated continuation.
        """
        pass

    @abstractmethod
    def calculate_importance(self, dataloader, method="original"):
        '''
            Docstring
        '''
        pass

    @classmethod
    def create_from_arg_string(cls, arg_string, additional_config=None):
        additional_config = {} if additional_config is None else additional_config
        args = utils.simple_parse_args_string(arg_string)
        args2 = {k: v for k, v in additional_config.items() if v is not None}
        return cls(**args, **args2)

    def set_cache_hook(self, cache_hook):
        self.cache_hook = cache_hook

def print_active_bytes():
    stats = torch.cuda.memory_stats()
    current_active_byte =  stats["active_bytes.all.current"]
    print(current_active_byte)

class BaseLM(LM):
    @property
    @abstractmethod
    def eot_token_id(self):
        pass

    @property
    @abstractmethod
    def max_length(self):
        pass

    @property
    @abstractmethod
    def max_gen_toks(self):
        pass

    @property
    @abstractmethod
    def batch_size(self):
        pass

    @property
    @abstractmethod
    def device(self):
        pass

    @abstractmethod
    def tok_encode(self, string: str):
        pass

    @abstractmethod
    def tok_decode(self, tokens: Iterable[int]):
        pass

    @abstractmethod
    def _model_generate(self, context, max_length, eos_token_id):
        pass

    @abstractmethod
    def _model_call(self, inps):
        """
        inps: a torch tensor of shape [batch, sequence]
        the size of sequence may vary from call to call

        returns: a torch tensor of shape [batch, sequence, vocab] with the
        logits returned from the model
        """
        pass

    def dataset_analysis(self, dataloader):
        l = []
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            batch_max_length = torch.max(l_ctx + l_cont).item()
            l.append(batch_max_length)
        return l    


    def calculate_oracle_ga(self, dataloader, method="NA", task="NA", num_fewshot=0):
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        device = self.device

        # Helper functions to apply and revert head mask
        def apply_head_mask(attention_module, head_mask):
            if not hasattr(attention_module, 'original_forward'):
                attention_module.original_forward = attention_module.forward

            def forward_with_head_mask(*args, **kwargs):
                output = attention_module.original_forward(*args, **kwargs)
                attn_output, attn_weights_reshaped, past_key_value = output

                if attn_weights_reshaped is not None:
                    head_mask_expanded = head_mask.view(1, -1, 1, 1)
                    attn_weights_reshaped = attn_weights_reshaped * head_mask_expanded

                return attn_output, attn_weights_reshaped, past_key_value

            attention_module.forward = forward_with_head_mask

        def revert_head_mask(attention_module):
            if hasattr(attention_module, 'original_forward'):
                attention_module.forward = attention_module.original_forward
                del attention_module.original_forward

        # Define the fitness function
        def evaluate(individual):
            model = self.opt.model
            head_mask = torch.tensor(individual, dtype=torch.float32).view(num_hidden_layers, num_heads)

            for layer in range(num_hidden_layers):
                self_attention = model.get_decoder().layers[layer].self_attn
                apply_head_mask(self_attention, head_mask[layer])

            model.eval()
            total_loss = 0
            izjns = 0

            for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
                izjns += 1
                if izjns > 200:
                    break
                batch_max_length = torch.max(l_ctx + l_cont).item()
                inp = inp[:, :batch_max_length]
                attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
                labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
                for i in range(len(l_ctx)):
                    attn_mask[i][l_ctx[i] + l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i] + l_cont[i]))
                    labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i] + l_cont[i]]

                ll = self._model_call(inp.to(device), attn_mask.to(device), labels.to(device))
                total_loss += ll.cpu().detach().item()

            for layer in range(num_hidden_layers):
                self_attention = model.get_decoder().layers[layer].self_attn
                revert_head_mask(self_attention)

            return (total_loss,)

        for sparsity_pc in [50, 60, 70, 80, 90, 92, 94, 96]:
            sparsity_pc = sparsity_pc / 100.
            # Set up the GA
            hof = tools.HallOfFame(10)
            creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
            creator.create("Individual", list, fitness=creator.FitnessMin)
            def init_individual(icls, size, sparsity):
                """Initialize the individual with a fixed number of 1's according to the sparsity."""
                total_ones = int((1 - sparsity) * size)  # Total number of ones
                individual = [1] * total_ones + [0] * (size - total_ones)
                random.shuffle(individual)
                return icls(individual)
            toolbox = base.Toolbox()
            toolbox.register("attr_bool", random.randint, 0, 1)
            toolbox.register("individual", init_individual, creator.Individual, 
                            size=num_hidden_layers * num_heads, sparsity=sparsity_pc)
            toolbox.register("population", tools.initRepeat, list, toolbox.individual)
            toolbox.register("evaluate", evaluate)

            def repair(individual, size, sparsity):
                """Repair the individual to maintain the desired sparsity level."""
                total_ones = int((1 - sparsity) * size)
                num_ones = sum(individual)
                
                # Add or remove 1's to meet the desired sparsity
                while num_ones > total_ones:
                    idx = random.choice([i for i, x in enumerate(individual) if x == 1])
                    individual[idx] = 0
                    num_ones -= 1
                while num_ones < total_ones:
                    idx = random.choice([i for i, x in enumerate(individual) if x == 0])
                    individual[idx] = 1
                    num_ones += 1
                return individual

            def crossover(ind1, ind2, sparsity):
                """Perform a crossover that maintains sparsity."""
                size = len(ind1)
                cxpoint = random.randint(1, size - 1)
                temp1 = ind1[:cxpoint] + ind2[cxpoint:]
                temp2 = ind2[:cxpoint] + ind1[cxpoint:]
                repair(temp1, size, sparsity)
                repair(temp2, size, sparsity)
                ind1[:] = temp1
                ind2[:] = temp2
                return ind1, ind2

            def mutate(individual, indpb, sparsity):
                """Mutate an individual by flipping a bit with probability indpb."""
                for i in range(len(individual)):
                    if random.random() < indpb:
                        individual[i] = type(individual[i])(not individual[i])
                repair(individual, len(individual), sparsity)
                return individual,

            toolbox.register("mate", crossover, sparsity=sparsity_pc)
            toolbox.register("mutate", mutate, indpb=0.05, sparsity=sparsity_pc)

            # total_elements = num_hidden_layers * num_heads
            # repair_function = partial(repair, size=total_elements, sparsity=sparsity_pc / 100.0)

            # # Register the repair function to be applied after mutation and crossover
            # toolbox.decorate("mutate", repair_function)
            # toolbox.decorate("mate", repair_function)
            toolbox.register("select", tools.selTournament, tournsize=3)

            population = toolbox.population(n=100)
            # open zcps/opt-1.3b/l2_norm_piqa_0.pkl 
            with open('zcps/opt-1.3b/nwot_copa_0.pkl', 'rb') as f: importance_score = pickle.load(f)
            prob_dist_mask = torch.functional.F.softmax(importance_score.detach().cpu().flatten())
            for ind in population:
                # sample a random mask based on the prob_dist_mask
                for i in range(len(ind)):
                    ind[i] = 1 if random.random() < prob_dist_mask[i] else 0
                # ensure ind is repaired
                ind = repair(ind, len(ind), sparsity_pc)
            # Configure statistics and logbook
            stats = tools.Statistics(lambda ind: ind.fitness.values)
            stats.register("avg", np.mean)
            stats.register("std", np.std)
            stats.register("min", np.min)
            stats.register("max", np.max)
            # stats.register("cum_min", lambda: min(ind.fitness.values[0] for ind in hof) if hof else float('inf'))

            logbook = tools.Logbook()
            logbook.header = "gen", "evals", "avg", "std", "min", "max"

            # Run the genetic algorithm
            population, logbook = algorithms.eaSimple(population, toolbox, cxpb=0.5, mutpb=0.2, ngen=100,
                                                    stats=stats, halloffame=hof, verbose=True)

            best_ind = tools.selBest(population, 1)[0]
            print('Best individual is %s, %s' % (best_ind, best_ind.fitness.values))
            if not os.path.exists('zcps'):
                os.makedirs('zcps')
            model_name = self.opt.config._name_or_path.replace("facebook/", "")
            base_path = f'zcps/{model_name}'
            if not os.path.exists(base_path):
                os.makedirs(base_path)

            for i, individual in enumerate(hof):
                head_mask = torch.tensor(individual, dtype=torch.float32).view(num_hidden_layers, num_heads)
                importance_score = torch.zeros(num_hidden_layers, num_heads)
                
                for layer in range(num_hidden_layers):
                    for head in range(num_heads):
                        importance_score[layer, head] = head_mask[layer, head]

                with open(os.path.join(base_path, f'oracle_ga_top_{i+1}_{sparsity_pc}_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl'), 'wb') as f:
                    pickle.dump(importance_score, f)
        return best_ind

    def calculate_oracle_opt(self, dataloader, method="NA", task="NA", num_fewshot=0):
        def apply_head_mask(attention_module, head_mask):
            if not hasattr(attention_module, 'original_forward'):
                attention_module.original_forward = attention_module.forward

            def forward_with_head_mask(*args, **kwargs):
                output = attention_module.original_forward(*args, **kwargs)
                attn_output, attn_weights_reshaped, past_key_value = output

                if attn_weights_reshaped is not None:
                    head_mask_expanded = head_mask.view(1, -1, 1, 1)
                    attn_weights_reshaped = attn_weights_reshaped * head_mask_expanded

                return attn_output, attn_weights_reshaped, past_key_value

            attention_module.forward = forward_with_head_mask


        def revert_head_mask(attention_module):
            if hasattr(attention_module, 'original_forward'):
                attention_module.forward = attention_module.original_forward
                del attention_module.original_forward

        def objective(trial, model, dataloader, num_hidden_layers, num_heads, device, sparsity_pc, logger):
            # Define binary mask as a trial parameter
            # binary_mask_flat = [trial.suggest_int(f'layer_{i}_head_{j}', 0, 1) for i in range(num_hidden_layers) for j in range(num_heads)]
            numc = int((sparsity_pc/100.)*num_hidden_layers*num_heads)
            binary_mask_ids = [trial.suggest_int(f'choice_{i}', 0, num_hidden_layers*num_heads-1) for i in range(numc)]
            # Make those indices 1
            binary_mask_flat = [1 if i in binary_mask_ids else 0 for i in range(num_hidden_layers*num_heads)]
            head_mask = torch.tensor(binary_mask_flat).view(num_hidden_layers, num_heads).float()

            for layer in range(num_hidden_layers):
                self_attention = model.get_decoder().layers[layer].self_attn
                apply_head_mask(self_attention, head_mask[layer])
            model.eval()
            total_loss = 0
            izjns = 0

            trial_thresholds = {range(0, 500): 100, range(500, 1000): 200, range(1000, 2000): 500}  # Extend this as needed


            for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
                izjns += 1
                if any(izjns > threshold for trial_range, threshold in trial_thresholds.items() if trial.number in trial_range):
                    break
                # if izjns > 10:
                #     break
                batch_max_length = torch.max(l_ctx + l_cont).item()
                inp = inp[:, :batch_max_length]
                attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
                labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
                for i in range(len(l_ctx)):
                    attn_mask[i][l_ctx[i] + l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i] + l_cont[i]))
                    labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i] + l_cont[i]]

                ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
                total_loss += ll.cpu().detach().item()
            total_loss = total_loss / izjns
            # Log trial information
            logger.info(f'Trial {trial.number}: Loss={total_loss}, Sparsity={sparsity_pc}, Params={trial.params}')
            
            for layer in range(num_hidden_layers):
                self_attention = model.get_decoder().layers[layer].self_attn
                revert_head_mask(self_attention)

            return total_loss
    
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        device = self.device
        
        import logging
        # for sparsity_pc in [50, 60, 70, 80, 90, 92, 94, 96]:
        for sparsity_pc in [94, 96]:
            study = optuna.create_study(direction="minimize")

            model_name = self.opt.config._name_or_path.replace("facebook/", "")
            base_path = f'zcps/{model_name}'
            if not os.path.exists(base_path):
                os.makedirs(base_path)
            if not os.path.exists('zcps'):
                os.makedirs('zcps')

            # Set up logging
            log_directory = f'{base_path}/oracle_opt_info'
            os.makedirs(log_directory, exist_ok=True)
            logging.basicConfig(filename=f'{log_directory}/log_sparsity_{sparsity_pc}.txt', level=logging.INFO)
            study.optimize(lambda trial: objective(trial, self.opt, dataloader, num_hidden_layers, num_heads, device, sparsity_pc, logging), n_trials=2000)

            best_trial = study.best_trial
            best_mask_flat = [best_trial.params[f'layer_{i}_head_{j}'] for i in range(num_hidden_layers) for j in range(num_heads)]
            best_mask = torch.tensor(best_mask_flat).view(num_hidden_layers, num_heads).float()

            importance_score = torch.zeros(num_hidden_layers, num_heads)
            for i in range(num_hidden_layers):
                for j in range(num_heads):
                    importance_score[i, j] = best_mask[i, j]

            with open(base_path + f'/oracle_opt_{sparsity_pc}_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(importance_score, f)

        return importance_score

    def calculate_snip(self, dataloader, method="NA", task="NA", num_fewshot=0):
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        self.opt.eval()
        encoding_dict = {}
        tracker = 0
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        
        izjns = 0
        def apply_mask(module, input, output):
            masked_outputs = []
            mask = module.mask  # Ensure mask is [1, num_heads, 1, 1] to broadcast correctly
            for head_output in output[2]:
                masked_output = head_output * mask
                masked_outputs.append(masked_output)
            return (output[0], output[1], tuple(masked_outputs))

        def apply_fc_mask(module, input, output):
            return module.mask * output

        def capture_gradients(module, grad_input, grad_output):
            module.stored_gradients = grad_output[0]

        def attach_hooks(model, num_heads):
            for name, module in model.named_modules():
                if module.__class__.__name__ == "OPTAttention":
                    module.mask = torch.ones(1, num_heads, 1, 1, requires_grad=True, dtype=torch.float16).to(self.device)
                    module.register_forward_hook(apply_mask)
                    module.register_backward_hook(capture_gradients)
        
        
        def attach_fc1_hooks(model, fc1_neurons):
            for name, module in model.named_modules():
                if "fc1" in name:
                    module.mask = torch.ones(1, fc1_neurons, requires_grad=True, dtype=torch.float16).to(self.device)
                    module.register_forward_hook(apply_fc_mask)
                    module.register_backward_hook(capture_gradients)
        
        def attach_fc2_hooks(model, fc2_neurons):
            for name, module in model.named_modules():
                if "fc2" in name:
                    module.mask = torch.ones(1, fc2_neurons, requires_grad=True, dtype=torch.float16).to(self.device)
                    module.register_forward_hook(apply_fc_mask)
                    module.register_backward_hook(capture_gradients)

        attach_hooks(self.opt, num_heads)
        if fc_metric_calc:
            attach_fc1_hooks(self.opt, fc1_neurons)
            attach_fc2_hooks(self.opt, fc2_neurons)
        

        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward()
            first_embedding = []
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            for layer in range(num_hidden_layers):
                # if layer == 0:
                # if layer==0: 
                first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                mask_gradient = self_attention.stored_gradients
                if fc_metric_calc:
                    fc1_layer = self.opt.get_decoder().layers[layer].fc1
                    # fc2_layer = self.opt.get_decoder().layers[layer].fc2
                    fc1_mask_gradient = fc1_layer.stored_gradients
                    # fc2_mask_gradient = fc2_layer.stored_gradients
                    snip_fc1_info = torch.sum(torch.abs(fc1_mask_gradient), dim=0).squeeze()
                    # snip_fc2_info = torch.sum(torch.abs(fc2_mask_gradient), dim=0).squeeze()
                    fc1_importance_score[layer] += snip_fc1_info.detach().cpu()
                    temp_fc1_score[layer] += snip_fc1_info.detach().cpu()
                    # fc2_importance_score[layer] += snip_fc2_info.detach().cpu()
                mask_gradient = rearrange(mask_gradient, 'b l (h d) -> b l h d', h=num_heads)
                snip_info = torch.sum(torch.abs(mask_gradient), dim=1).sum(dim=-1).squeeze()
                # snip_info = torch.einsum("bhli,bhli->bhl", [grad_attn_x, attn_x]).to('cpu') # not all layers are on the same device hence make sure dot is on the self.device
                importance_score[layer] += snip_info.detach().cpu()
                temp_importance_score[layer] = snip_info.detach().cpu()
            
            if method == "predictor":
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del ll            
            for param in self.opt.parameters():
                param.grad = None
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/snip_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
            
        if method == "predictor":
            with open(base_path + f'/snip_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/fc1_snip_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/fc2_snip_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score

    def calculate_plainact(self, dataloader, method="NA", task="NA", num_fewshot=0):
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
        tot_tokens, eff_tokens = 0, 0
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        if fc_metric_calc:
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        izjns = 0
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 500:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward()
            first_embedding = []
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            for layer in range(num_hidden_layers):
                # if layer == 0:
                # if layer==0: 
                emb_trace = self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach()
                if torch.isnan(emb_trace).any():
                    import pdb; pdb.set_trace()
                first_embedding.append(emb_trace)
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad
                if fc_metric_calc:
                    fc1_weight = self.opt.get_decoder().layers[layer].fc1.weight
                    fc2_weight = self.opt.get_decoder().layers[layer].fc2.weight
                    fc1_weight_grad = self.opt.get_decoder().layers[layer].fc1.weight.grad
                    fc2_weight_grad = self.opt.get_decoder().layers[layer].fc2.weight.grad

                dim = attn_x.shape[-1]
                attn_x, grad_attn_x = map(lambda x: rearrange(x, 'b l (h d) -> b h l d', h=num_heads, d=dim//num_heads), (attn_x, grad_attn_x)) # shape = bs, num_heads, seq_len, dim_per_head
                plainact_info = torch.einsum("bhli,bhli->bhl", [grad_attn_x, attn_x]).to('cpu') # not all layers are on the same device hence make sure dot is on the self.device
                importance_score[layer] += plainact_info.abs().sum(-1).sum(0).cpu().detach() # [num_layers, num_heads]
                temp_importance_score[layer] += plainact_info.abs().sum(-1).sum(0).cpu().detach()
                
                if fc_metric_calc:
                    plainact_f1info = fc1_weight_grad * fc1_weight
                    fc1_importance_score[layer] += plainact_f1info.abs().sum(-1).cpu().detach()
                    temp_fc1_score[layer] = plainact_f1info.abs().sum(-1).cpu().detach()
                    # plainact_f2info = fc2_weight_grad * fc2_weight
                    # fc2_importance_score[layer] += plainact_f2info.abs().sum(-1).cpu().detach()
            if method == "predictor":
                # pdb here if anything is nan
                if torch.isnan(plainact_info).any() or torch.isnan(plainact_f1info).any():
                    import pdb; pdb.set_trace()
                # [1, L, E] --> Predictor --> [1, N * H]\
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, ll
            # input: [1, L, E] (seq len, emb.dim) --> Predictor --> [1, N, H] (Num Layers, Num Heads)
            
            if fc_metric_calc:
                del fc1_weight, fc2_weight, fc1_weight_grad, fc2_weight_grad
            for param in self.opt.parameters():
                param.grad = None
            
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/plainact_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        if method == "predictor":
            with open(base_path + f'/plainact_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
            
        if fc_metric_calc:
            with open(base_path + f'/fc1_plainact_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/fc2_plainact_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score
    
    def calculate_nwot(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        if fc_metric_calc:
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        izjns = 0
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            # if izjns > 10:
            #     break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            first_embedding = []
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            for layer in tqdm(range(num_hidden_layers)):
                # clear cuda cache
                torch.cuda.empty_cache()
                # if layer == 0:
                # if layer==0: 
                first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                attn_x = rearrange(attn_x, 'b l (h d) -> b l h d', h=num_heads)
                
                if fc_metric_calc:
                    fc1_output_act = self.opt.get_decoder().layers[layer].fc1_output
                    # fc2_output_act = self.opt.get_decoder().layers[layer].fc2_output

                for h_ in range(num_heads):
                    x = (attn_x > 0).float()[:, :, h_, :]
                    x = x.reshape(x.shape[0], -1)
                    # K = x @ x.t()  # Hamming distance
                    K2 = (1. - x) @ (1. - x.t())
                    K = K2.cpu().numpy()  # combine the two parts
                    del K2, x
                    s, jc = np.linalg.slogdet(K)
                    importance_score[layer, h_] += jc
                    temp_importance_score[layer, h_] += jc
                
                if fc_metric_calc:
                    fc1_x = (fc1_output_act > 0).float()
                    seqlen = fc1_x.shape[0]
                    K2_fc1 = torch.diag(torch.matmul((1. - fc1_x).t(), 1. - fc1_x))/seqlen
                    K_fc1 = K2_fc1.cpu().numpy()
                    del K2_fc1, fc1_x
                    # fc2_x = (fc2_output_act > 0).float()
                    # K2_fc2 = torch.diag(torch.matmul((1. - fc2_x).t(), 1. - fc2_x))/seqlen
                    # K_fc2 = K2_fc2.cpu().numpy()
                    for n_ in range(fc1_neurons):
                        K_value = K_fc1[n_]
                        if K_value > 0:
                            fc1_importance_score[layer, n_] += np.log(K_value)
                            temp_fc1_score[layer, n_] += np.log(K_value)
                        else:
                            fc1_importance_score[layer, n_] += -np.inf
                    # for n_ in range(fc2_neurons):
                    #     K_value = K_fc2[n_]
                    #     if K_value > 0:
                    #         fc2_importance_score[layer, n_] += np.log(K_value)
                    #     else:
                    #         fc2_importance_score[layer, n_] += -np.inf

            
            if method == "predictor":
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, ll
            
            if fc_metric_calc:
                del fc1_output_act
            for param in self.opt.parameters():
                param.grad = None
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/nwot_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
            
        if method == "predictor":
            with open(base_path + f'/nwot_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/fc1_nwot_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/fc2_nwot_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score

    def calculate_l2_norm(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        fc_metric_calc = hasattr(self.opt.get_decoder().layers[0], 'fc1') and hasattr(self.opt.get_decoder().layers[0], 'fc2')
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        if fc_metric_calc:
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        izjns = 0
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long, device=self.device)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long, device=self.device).fill_(-100)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]), device=self.device)
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().sum().item() - 1
                eff_tokens += (labels[i] != -100).sum().item()
            
            with torch.no_grad():
                ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
                token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().cpu()
                first_embedding = []
                temp_importance_score = torch.zeros(num_hidden_layers, num_heads, device=self.device)
                temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons) if fc_metric_calc else None
                for layer in range(num_hidden_layers):
                    first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                    self_attention = self.opt.get_decoder().layers[layer].self_attn
                    if fc_metric_calc:
                        fc1_output_act = self.opt.get_decoder().layers[layer].fc1_output
                        # fc2_output_act = self.opt.get_decoder().layers[layer].fc2_output
                    attn_x = self_attention.context_layer_val
                    attn_x = rearrange(attn_x, 'b l (h d) -> b l h d', h=num_heads)
                    l2_norm_info = attn_x.norm(dim=0).norm(dim=0).norm(dim=-1).cpu().detach()
                    importance_score[layer] += l2_norm_info
                    temp_importance_score[layer] = l2_norm_info
                    del attn_x, l2_norm_info  # Free memory
                    if fc_metric_calc:
                        fc1_importance_score[layer] += fc1_output_act.norm(dim=0).cpu().detach()
                        temp_fc1_score[layer] += fc1_output_act.norm(dim=0).cpu().detach()
                        # fc2_importance_score[layer] += fc2_output_act.norm(dim=0).cpu().detach()
                        del fc1_output_act  # Free memory
                if method == "predictor":
                    encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score.cpu(), temp_fc1_score.cpu() if fc_metric_calc else None)
                    tracker += 1
            
            self.opt.zero_grad()
            torch.cuda.empty_cache()  # Clear the cache to free up memory

        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score.cpu(), f)
            
        if method == "predictor":
            with open(base_path + f'/l2_norm_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/fc1_l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score.cpu(), f)
            # with open(base_path + f'/fc2_l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score.cpu(), f)
        return importance_score.cpu()
    # def calculate_l2_norm(self, dataloader, method="NA", task="NA", num_fewshot=0):
    #     """
    #     For EPE-NAS, we need to go through each item in data loader
    #     For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
    #     """
    #     num_hidden_layers = self.opt.config.num_hidden_layers
    #     num_heads = self.opt.config.num_attention_heads
    #     tot_tokens, eff_tokens = 0, 0
    #     if fc_metric_calc:
    #         fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
    #         fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
    #     self.opt.eval()
    #     importance_score = torch.zeros(num_hidden_layers, num_heads)
    #     if fc_metric_calc:
    #         fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
    #         fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
    #     izjns = 0
    #     encoding_dict = {}
    #     tracker = 0
    #     for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
    #         izjns += 1
    #         if izjns > 10:
    #             break
    #         batch_max_length = torch.max(l_ctx + l_cont).item()
    #         inp = inp[:, :batch_max_length]
    #         attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
    #         labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
    #         for i in range(len(l_ctx)):
    #             attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
    #             labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
    #             tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
    #             eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
    #         ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
    #         token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
    #         first_embedding = []
    #         temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
    #         temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
    #         for layer in range(num_hidden_layers):
    #             # if layer==0: 
    #             first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
    #             self_attention = self.opt.get_decoder().layers[layer].self_attn
    #             if fc_metric_calc:
    #                 fc1_output_act = self.opt.get_decoder().layers[layer].fc1_output
    #                 fc2_output_act = self.opt.get_decoder().layers[layer].fc2_output
    #             attn_x = self_attention.context_layer_val
    #             attn_x = rearrange(attn_x, 'b l (h d) -> b l h d', h=num_heads)
    #             l2_norm_info = attn_x.norm(dim=0).norm(dim=0).norm(dim=-1)
    #             importance_score[layer] += l2_norm_info.cpu()
    #             temp_importance_score[layer] = l2_norm_info.cpu()
    #             del attn_x, l2_norm_info  # Free memory
    #             if fc_metric_calc:
    #                 fc1_importance_score[layer] += fc1_output_act.norm(dim=0).cpu()
    #                 temp_fc1_score[layer] += fc1_output_act.norm(dim=0).cpu()
    #                 fc2_importance_score[layer] += fc2_output_act.norm(dim=0).cpu()
    #                 del fc1_output_act, fc2_output_act  # Free memory
    #         if method == "predictor":
    #             encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
    #             tracker += 1
    #         self.opt.zero_grad()
    #         del ll  # Free memory
    #         for param in self.opt.parameters():
    #             param.grad = None
    #         torch.cuda.empty_cache()  # Clear the cache to free up memory
            
    #     # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
    #     model_name = self.opt.config._name_or_path.replace("facebook/", "")
    #     if not os.path.exists(f'zcps'):
    #         os.makedirs(f'zcps')
    #     base_path = f'zcps/{model_name}'
    #     # ensure base_path exists?
    #     if not os.path.exists(base_path):
    #         os.makedirs(base_path)
    #     with open(base_path + f'/l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
    #         pickle.dump(importance_score, f)
            
    #     if method == "predictor":
    #         with open(base_path + f'/l2_norm_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
    #             pickle.dump(encoding_dict, f)
    #     if fc_metric_calc:
    #         with open(base_path + f'/fc1_l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
    #             pickle.dump(fc1_importance_score, f)
    #         # with open(base_path + f'/fc2_l2_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
    #         #     pickle.dump(fc2_importance_score, f)
    #     return importance_score
    

    def calculate_jacov(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        izjns = 0
        # For each head in each layer, stack the [b, l, d] grad_attn_x across the dataloader
        perhead_class_jacobians = {"l_{}".format(i): {"h_{}".format(h): [] for h in range(num_heads)} for i in range(num_hidden_layers)}
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            ll.backward(retain_graph=True)
            for layer in range(num_hidden_layers):
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad
                
                dim = attn_x.shape[-1]
                attn_x, grad_attn_x = map(lambda x: rearrange(x, 'b l (h d) -> b l h d', h=num_heads, d=dim//num_heads), (attn_x, grad_attn_x))
                for h_ in range(num_heads):
                    # if len(perhead_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)]) == 0:
                    #     perhead_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)] = [grad_attn_x[:, :, h_, :].squeeze()]
                    for l_ in range(grad_attn_x.shape[1]):
                        perhead_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)].append(grad_attn_x[:, l_, h_, :].squeeze())
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, ll
            for param in self.opt.parameters():
                param.grad = None
        for layer in range(num_hidden_layers):
            for head in tqdm(range(num_heads)):
                jacobians = torch.stack(perhead_class_jacobians["l_{}".format(layer)]["h_{}".format(head)], dim=0).cpu()
                # remove wherever jacobians.sum(dim=-1) == 0
                jacobians = jacobians[jacobians.sum(dim=-1) != 0]
                subsample_size = 200
                # Randomly sample 100 jacobians
                jc_values = []
                for _ in range(10):
                    subsample = jacobians[torch.randperm(jacobians.shape[0])[:subsample_size]]
                    corrs = np.corrcoef(subsample)
                    v, _ = np.linalg.eig(corrs)
                    v = np.abs(v)
                    k = 1e-5
                    jc = -np.sum(np.log(v + k) + 1.0 / (v + k))
                    jc_values.append(jc)
                avg_jc = np.mean(jc_values)
                # import pdb; pdb.set_trace()
                # corrs = np.corrcoef(jacobians)
                # v, _ = np.linalg.eig(corrs)
                # v = np.abs(v)
                # k = 1e-5
                # jc = -np.sum(np.log(v + k) + 1.0 / (v + k))
                # If a complex number comes, just try v = np.abs(v) or corrs += np.eye(corrs.shape[0]) * k
                importance_score[layer, head] += avg_jc
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/jacov_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        return importance_score


    def calculate_grasp(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
        tot_tokens, eff_tokens = 0, 0
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        if fc_metric_calc:
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        izjns = 0
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward(retain_graph=True)
            grad_w = [self.opt.get_decoder().layers[layer].self_attn.context_layer_val_grad.clone() for layer in range(num_hidden_layers)]
            
            if fc_metric_calc:
                grad_w_f1 = [self.opt.get_decoder().layers[layer].fc1.weight.grad.clone() for layer in range(num_hidden_layers)]
                grad_w_f2 = [self.opt.get_decoder().layers[layer].fc2.weight.grad.clone() for layer in range(num_hidden_layers)]
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            # TODO: Backward pass below is WRONG
            ll.backward(create_graph=True)
            z = 0
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            first_embedding = []
            for layer in range(num_hidden_layers):
                # if layer == 0:
                # if layer==0: 
                first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                num_heads = self_attention.num_heads
                grad_attn_x = self_attention.context_layer_val_grad
                z += (grad_w[layer] * grad_attn_x).mean()
                if fc_metric_calc:
                    fc1_weight_grad = self.opt.get_decoder().layers[layer].fc1.weight.grad
                    # fc2_weight_grad = self.opt.get_decoder().layers[layer].fc2.weight.grad
                    z += (grad_w_f1[layer] * fc1_weight_grad).mean()
                    # z += (grad_w_f2[layer] * fc2_weight_grad).mean()
            z.backward()
            for layer in range(num_hidden_layers):
                self_attention_grad = self.opt.get_decoder().layers[layer].self_attn.context_layer_val_grad
                if fc_metric_calc:
                    fc1_weight_grad = self.opt.get_decoder().layers[layer].fc1.weight.grad
                    # fc2_weight_grad = self.opt.get_decoder().layers[layer].fc2.weight.grad
                # fc1 fc2 weights, attn map
                self_attention = self.opt.get_decoder().layers[layer].self_attn.context_layer_val
                if fc_metric_calc:
                    fc1_weight = self.opt.get_decoder().layers[layer].fc1.weight
                    fc2_weight = self.opt.get_decoder().layers[layer].fc2.weight
                self_attn_metrics = -self_attention_grad * self_attention
                if fc_metric_calc:
                    fc1_metrics = -fc1_weight_grad * fc1_weight
                    # fc2_metrics = -fc2_weight_grad * fc2_weight
                # rearrange self_attn_metrics 
                self_attn_metrics = rearrange(self_attn_metrics, 'b l (h d) -> b l h d', h=num_heads)
                # mean on second dim
                if fc_metric_calc:
                    fc1_metrics = fc1_metrics.mean(dim=-1)
                    # fc2_metrics = fc2_metrics.mean(dim=-1)
                self_attn_metrics = self_attn_metrics.sum(dim=0).mean(dim=0).sum(dim=-1)
                importance_score[layer] += self_attn_metrics.detach().cpu()
                temp_importance_score[layer] += self_attn_metrics.detach().cpu()
                if fc_metric_calc:
                    fc1_importance_score[layer] += fc1_metrics.detach().cpu()
                    temp_fc1_score[layer] += fc1_metrics.detach().cpu()
                    # fc2_importance_score[layer] += fc2_metrics.detach().cpu()
            if method == "predictor":
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del ll
            if fc_metric_calc:
                del fc1_weight_grad
            for param in self.opt.parameters():
                param.grad = None
            
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/grasp_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        if method == "predictor":
            with open(base_path + f'/grasp_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/grasp_fc1_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/grasp_fc2_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score

    def calculate_grad_norm(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        if fc_metric_calc:
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        izjns = 0
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward()
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            first_embedding = []
            for layer in range(num_hidden_layers):
                # if layer == 0:
                # if layer==0: 
                first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad  
                if fc_metric_calc:          
                    fc1_weight_grad = self.opt.get_decoder().layers[layer].fc1.weight.grad
                    # fc2_weight_grad = self.opt.get_decoder().layers[layer].fc2.weight.grad
                grad_attn_x = rearrange(grad_attn_x, 'b l (h d) -> b l h d', h=num_heads)
                grad_norm_info = grad_attn_x.norm(dim=0).norm(dim=0).norm(dim=-1)
                importance_score[layer] += grad_norm_info.cpu().detach()
                temp_importance_score[layer] = grad_norm_info.cpu().detach()
                if fc_metric_calc:
                    fc1_grad_norm_info = fc1_weight_grad.norm(dim=-1)
                    fc1_importance_score[layer] += fc1_grad_norm_info.cpu().detach()
                    temp_fc1_score[layer] = fc1_grad_norm_info.cpu().detach()
                    # fc2_grad_norm_info = fc2_weight_grad.norm(dim=-1)
                    # fc2_importance_score[layer] += fc2_grad_norm_info.cpu().detach()
            
            if method == "predictor":
                # import pdb; pdb.set_trace()
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, ll
            if fc_metric_calc:
                del fc1_weight_grad

            for param in self.opt.parameters():
                param.grad = None
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/grad_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        if method == "predictor":
            with open(base_path + f'/grad_norm_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/fc1_grad_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/fc2_grad_norm_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score
    

    def calculate_fisher(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        if fc_metric_calc:
            fc1_neurons = self.opt.get_decoder().layers[0].fc1.out_features
            fc2_neurons = self.opt.get_decoder().layers[0].fc2.out_features
            fc1_importance_score = torch.zeros(num_hidden_layers, fc1_neurons)
            fc2_importance_score = torch.zeros(num_hidden_layers, fc2_neurons)
        self.opt.eval()
        encoding_dict = {}
        tracker = 0
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        izjns = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward()
            first_embedding = []
            temp_importance_score = torch.zeros(num_hidden_layers, num_heads)
            temp_fc1_score = torch.zeros(num_hidden_layers, fc1_neurons)
            for layer in range(num_hidden_layers):
                # if layer == 0:
                # if layer==0: 
                first_embedding.append(self.opt.get_decoder().layers[layer].self_attn.context_layer_val[:, -1, :].cpu().detach())
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad
                
                if fc_metric_calc:
                    fc1_weight = self.opt.get_decoder().layers[layer].fc1.weight
                    # fc2_weight = self.opt.get_decoder().layers[layer].fc2.weight
                    fc1_weight_grad = self.opt.get_decoder().layers[layer].fc1.weight.grad
                    # fc2_weight_grad = self.opt.get_decoder().layers[layer].fc2.weight.grad
                    fc1_input_act = self.opt.get_decoder().layers[layer].fc1_input
                    fc1_input_act_grad = self.opt.get_decoder().layers[layer].fc1_input_grad
                    # fc2_input_act = self.opt.get_decoder().layers[layer].fc2_input
                    # fc2_input_act_grad = self.opt.get_decoder().layers[layer].fc2_input_grad
                    fc1_output_act = self.opt.get_decoder().layers[layer].fc1_output
                    fc1_output_act_grad = self.opt.get_decoder().layers[layer].fc1_output_grad
                    # fc2_output_act = self.opt.get_decoder().layers[layer].fc2_output
                    # fc2_output_act_grad = self.opt.get_decoder().layers[layer].fc2_output_grad

                fisher_info = (attn_x * grad_attn_x).pow(2).mean(dim=[0, 1]).reshape(num_heads, -1).sum(dim=-1)  # averaging over batch and sequence length
                importance_score[layer] += fisher_info.cpu().detach()
                temp_importance_score[layer] += fisher_info.cpu().detach()
                if fc_metric_calc:
                    fc1_fisher_info = (fc1_output_act * fc1_output_act_grad).pow(2).mean(dim=[0])
                    fc1_importance_score[layer] += fc1_fisher_info.cpu().detach()
                    temp_fc1_score[layer] += fc1_fisher_info.cpu().detach()
                    # fc2_fisher_info = (fc2_output_act * fc2_output_act_grad).pow(2).mean(dim=[0])
                    # fc2_importance_score[layer] += fc2_fisher_info.cpu().detach()
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, ll
            if fc_metric_calc:
                del fc1_weight, fc1_weight_grad, fc1_input_act, fc1_input_act_grad, fc1_output_act, fc1_output_act_grad
            for param in self.opt.parameters():
                param.grad = None
            
            if method == "predictor":
                encoding_dict[tracker] = (token_embedding, first_embedding, temp_importance_score, temp_fc1_score)
                tracker += 1
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/fisher_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        if method == "predictor":
            with open(base_path + f'/fisher_trace_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
        if fc_metric_calc:
            with open(base_path + f'/fc1_fisher_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
                pickle.dump(fc1_importance_score, f)
            # with open(base_path + f'/fc2_fisher_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            #     pickle.dump(fc2_importance_score, f)
        return importance_score
    

    def calculate_epenas(self, dataloader, method="NA", task="NA", num_fewshot=0):
        """
        For EPE-NAS, we need to go through each item in data loader
        For EACH layer AND HEAD, have a dictionary mapping the class to all jacobians.
        """
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        self.opt.eval()
        importance_score = torch.zeros(num_hidden_layers, num_heads)
        perlayer_class_jacobians = {"l_{}".format(i): {"h_{}".format(h): defaultdict(list) for h in range(num_heads)} for i in range(num_hidden_layers)}
        izjns = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            izjns += 1
            if izjns > 10:
                break
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            ll.backward()
            for layer in range(num_hidden_layers):
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad

                dim = attn_x.shape[-1]
                attn_x, grad_attn_x = map(lambda x: rearrange(x, 'b l (h d) -> b l h d', h=num_heads, d=dim//num_heads), (attn_x, grad_attn_x))

                # Now, grad_attn_x is of shape [1, seq_len, num_heads, dim_per_head]
                # populate perlayer_class_jacobians with the jacobians, using label of seq_len as key, layer and head from num_heads as key
                for h_ in range(num_heads):
                    for lab_ix, lab in enumerate(labels[0]):
                        lab = lab.item()
                        if lab != -100.:
                            if lab in perlayer_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)]:
                                perlayer_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)][lab] = np.vstack((perlayer_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)][lab], grad_attn_x[0, lab_ix-1, h_, :].detach().cpu().numpy().tolist()))
                            else:
                                perlayer_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)][lab] = [grad_attn_x[0, lab_ix-1, h_, :].detach().cpu().numpy().tolist()]
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, ll
            
            for param in self.opt.parameters():
                param.grad = None
        classes = list(perlayer_class_jacobians["l_0"]["h_0"].keys())
        print("Number of items per class: ", {c: len(perlayer_class_jacobians["l_0"]["h_0"][c]) for c in classes})
        # keep only classes that have more than 10 samples
        classes = [c for c in classes if len(perlayer_class_jacobians["l_0"]["h_0"][c]) > 4]
        ind_corr_matrix_score = {"l_{}".format(i): {"h_{}".format(h): {} for h in range(num_heads)} for i in range(num_hidden_layers)}
        # per_class = {"l_{}".format(i): {"h_{}".format(h): defaultdict(list) for h in range(num_heads)} for i in range(num_hidden_layers)}
        for layer in range(num_hidden_layers):
            for h_ in range(num_heads):
                for c in classes:
                    s = 0
                    try:
                        corrs = np.array(np.corrcoef(perlayer_class_jacobians["l_{}".format(layer)]["h_{}".format(h_)][c]))
                        s = np.sum(np.log(abs(corrs)+1e-5))
                        # check if s is 'nan'
                        if not np.isnan(s):
                            ind_corr_matrix_score["l_{}".format(layer)]["h_{}".format(h_)][c] = s
                    except Exception as e:
                        print("Skipping because of : ", e)
                        continue
                for c in ind_corr_matrix_score["l_{}".format(layer)]["h_{}".format(h_)].keys():
                    score = 0
                    for cj in ind_corr_matrix_score["l_{}".format(layer)]["h_{}".format(h_)].keys():
                        score += np.absolute(ind_corr_matrix_score["l_{}".format(layer)]["h_{}".format(h_)][c] - ind_corr_matrix_score["l_{}".format(layer)]["h_{}".format(h_)][cj])
                    importance_score[layer][h_] += score
        # Save it as 'epenas' + task.DATASET_PATH + str(num_fewshot) + '.pkl' in a new directory called 'zcps/' + self.opt.config._name_or_path.replace("facebook/", "") + "/"
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        if not os.path.exists(f'zcps'):
            os.makedirs(f'zcps')
        base_path = f'zcps/{model_name}'
        # ensure base_path exists?
        if not os.path.exists(base_path):
            os.makedirs(base_path)
        with open(base_path + f'/epenas_{task.DATASET_NAME if task.DATASET_NAME is not None else task.DATASET_PATH}_{num_fewshot}.pkl', 'wb') as f:
            pickle.dump(importance_score, f)
        return importance_score

    def calculate_importance(self, dataloader, method="original", task="NotProvided", num_fewshot=0):
        num_hidden_layers = self.opt.config.num_hidden_layers
        num_heads = self.opt.config.num_attention_heads
        tot_tokens, eff_tokens = 0, 0
        if method != "predictor":
            importance_score = torch.zeros(num_hidden_layers, num_heads).to('cpu')
        ## disable dropout
        self.opt.eval()
        encoding_dict = {}
        tracker = 0
        for ctx, cont, inp, l_ctx, l_cont in tqdm(dataloader):
            if method == "predictor":
                importance_score = torch.zeros(num_hidden_layers, num_heads).to('cpu')
            batch_max_length = torch.max(l_ctx + l_cont).item()
            inp = inp[:, :batch_max_length]
            attn_mask = torch.ones((len(l_ctx), batch_max_length), dtype=torch.long)
            labels = torch.empty((len(l_ctx), batch_max_length), dtype=torch.long).fill_(-100.)
            for i in range(len(l_ctx)):
                attn_mask[i][l_ctx[i]+l_cont[i]:] = torch.zeros(batch_max_length - (l_ctx[i]+l_cont[i]))
                labels[i][l_ctx[i]: l_ctx[i] + l_cont[i]] = inp[i][l_ctx[i]:l_ctx[i]+l_cont[i]]
                tot_tokens += attn_mask[i].float().cpu().detach().sum().data - 1 ## if the length of the sequence is N, then the gradient is calculated over N - 1 tokens
                eff_tokens += (labels[i] != -100.).cpu().detach().sum().data ## we won't have gradients for non-label positions in the last layer
            ll = self._model_call(inp.to(self.device), attn_mask.to(self.device), labels.to(self.device))
            token_embedding = self.opt.model.decoder.embed_tokens(inp.to(self.device)).detach().to("cpu")[:, -1, :]
            ll.backward()
            for layer in range(num_hidden_layers):
                self_attention = self.opt.get_decoder().layers[layer].self_attn
                attn_x = self_attention.context_layer_val
                grad_attn_x = self_attention.context_layer_val_grad
                dim = attn_x.shape[-1]
                if method in ["original", "predictor"]:
                    attn_x, grad_attn_x = map(lambda x: rearrange(x, 'b l (h d) -> b h l d', h=num_heads, d=dim//num_heads), (attn_x, grad_attn_x)) # shape = bs, num_heads, seq_len, dim_per_head
                    dot = torch.einsum("bhli,bhli->bhl", [grad_attn_x, attn_x]).to('cpu') # not all layers are on the same device hence make sure dot is on the self.device
                    importance_score[layer] += dot.abs().sum(-1).sum(0).detach()
                    # Convert to softmax
                elif method == "headmagn":
                    attn_x, grad_attn_x = map(lambda x: rearrange(x, 'b l (h d) -> b h l d', h=num_heads, d=dim//num_heads), (attn_x, grad_attn_x)) # shape = bs, num_heads, seq_len, dim_per_head
                    # Here, we reduce over the 'i' dimension to get the importance score for each head
                    dot = torch.einsum("bhli,bhli->bhl", [attn_x, attn_x]).to('cpu') # not all layers are on the same device hence make sure dot is on the self.device
                    magnmap = dot.abs().sum(-1).sum(0).detach()
                    importance_score[layer] += magnmap.detach().to("cpu")
                # elif method == "predictor":
                #     # Here, we use the predictor emitted output for the importance score
                #     # the predictor should be trained on 30% of the importance dictionary generated above
                #     # and then generate for everything.
                #     # However, we should change our evaluate method to only  use the latter 70% of the dataset
                #     headpred = headpredictor_dict[layer].to(self.device)
                #     magnmap = headpred(token_embedding.to(self.device).float()).detach().to("cpu").squeeze()
                #     importance_score[layer] += magnmap.detach().to("cpu")
                else:
                    raise ValueError("Invalid method")
                
            if method == "predictor":
                encoding_dict[tracker] = (token_embedding, importance_score)
                tracker += 1
            ## helps in reducing the memory footprint
            self.opt.zero_grad()
            del attn_x, grad_attn_x, dot, ll
            # self.ds_engine.module.zero_grad()
            for param in self.opt.parameters():
                param.grad = None
            tracker += 1
        model_name = self.opt.config._name_or_path.replace("facebook/", "")
        base_path = f'pl_traces_{model_name}'
        # Save the encoding_dict as a pt file
        if method == "predictor":
            with open(base_path + f'/{num_fewshot}_shot_trace_{task}_{method}.pkl', 'wb') as f:
                pickle.dump(encoding_dict, f)
            exit(0)
        importance_score[:-1] /= tot_tokens
        importance_score[-1] /= eff_tokens
        return importance_score

    def loglikelihood(self, requests):
        new_reqs = []
        for context, continuation in requests:
            if context == "":
                # end of text as context
                context_enc = [self.eot_token_id]
            else:
                context_enc = self.tok_encode(context)

            continuation_enc = self.tok_encode(continuation)

            new_reqs.append(((context, continuation), context_enc, continuation_enc))

        return self._loglikelihood_tokens(new_reqs)

    def loglikelihood_rolling(self, requests):
        # TODO: Implement caching once we've confirmed the perplexity implementation
        # TODO: automatic batch size detection for vectorization

        loglikelihoods = []
        for (string,) in tqdm(requests):
            rolling_token_windows = list(
                map(
                    utils.make_disjoint_window,
                    utils.get_rolling_token_windows(
                        token_list=self.tok_encode(string),
                        prefix_token=self.eot_token_id,
                        max_seq_len=self.max_length,
                        context_len=1,
                    ),
                )
            )

            rolling_token_windows = [(None,) + x for x in rolling_token_windows]

            # TODO: extract out this call so it only gets called once and also somehow figure out partial caching for
            # that
            string_nll = self._loglikelihood_tokens(
                rolling_token_windows, disable_tqdm=True
            )

            # discard is_greedy
            string_nll = [x[0] for x in string_nll]

            string_nll = sum(string_nll)
            loglikelihoods.append(string_nll)

        return loglikelihoods

    def _loglikelihood_tokens(self, requests, disable_tqdm=False):
        # TODO: implement some kind of efficient-request-middleware that lumps together requests with the same context
        res = []

        def _collate(x):
            # the negative sign on len(toks) sorts descending - this has a few advantages:
            # - time estimates will always be over not underestimates, which is more useful for planning
            # - to know the size of a batch when going through the list, you know the first one is always the batch
            #   padded context length. this is useful to simplify the batching logic and more importantly to make
            #   automatic adaptive batches much much easier to implement
            # - any OOMs will happen right away rather than near the end

            toks = x[1] + x[2]
            return -len(toks), tuple(toks)

        # TODO: automatic (variable) batch size detection for vectorization
        re_ord = utils.Reorderer(requests, _collate)
        for chunk in utils.chunks(
            tqdm(re_ord.get_reordered(), disable=disable_tqdm), self.batch_size
        ):
            inps = []
            cont_toks_list = []
            inplens = []

            padding_length = None

            # because vectorizing is annoying, we first convert each (context, continuation) pair to padded
            # tensors, then we pack them together into a batch, call the model, and then pick it all apart
            # again because vectorizing is annoying

            for _, context_enc, continuation_enc in chunk:
                # sanity check
                assert len(context_enc) > 0
                assert len(continuation_enc) > 0
                assert len(continuation_enc) <= self.max_length

                # how this all works:
                #          CTX      CONT
                # inp    0 1 2 3|4 5 6 7 8 9   <- last token is deleted by inp[:, :-1]
                # gpt2    \               \
                # logits   1 2 3|4 5 6 7 8 9   <- the ctx half gets tossed out by the
                # cont_toks      4 5 6 7 8 9      [:, -len(continuation_enc):, :self.vocab_size] slice

                # when too long to fit in context, truncate from the left
                inp = torch.tensor(
                    (context_enc + continuation_enc)[-(self.max_length + 1) :][:-1],
                    dtype=torch.long,
                ).to(self.device)
                (inplen,) = inp.shape

                cont = continuation_enc

                # since in _collate we make sure length is descending, the longest is always the first one.
                padding_length = (
                    padding_length if padding_length is not None else inplen
                )

                # pad length from seq to padding_length
                inp = torch.cat(
                    [
                        inp,  # [seq]
                        torch.zeros(padding_length - inplen, dtype=torch.long).to(
                            inp.device
                        ),  # [padding_length - seq]
                    ],
                    dim=0,
                )

                inps.append(inp.unsqueeze(0))  # [1, padding_length]
                cont_toks_list.append(cont)
                inplens.append(inplen)

            batched_inps = torch.cat(inps, dim=0)  # [batch, padding_length
            multi_logits = F.log_softmax(
                self._model_call(batched_inps), dim=-1
            ).cpu()  # [batch, padding_length, vocab]

            for (cache_key, _, _), logits, inp, inplen, cont_toks in zip(
                chunk, multi_logits, inps, inplens, cont_toks_list
            ):

                # Slice to original seq length
                contlen = len(cont_toks)
                logits = logits[inplen - contlen : inplen].unsqueeze(
                    0
                )  # [1, seq, vocab]

                # Check if per-token argmax is exactly equal to continuation
                greedy_tokens = logits.argmax(dim=-1)
                cont_toks = torch.tensor(cont_toks, dtype=torch.long).unsqueeze(
                    0
                )  # [1, seq]
                max_equal = (greedy_tokens == cont_toks).all()

                # Obtain log-probs at the corresponding continuation token indices
                # last_token_slice = logits[:, -1, :].squeeze(0).tolist()
                logits = torch.gather(logits, 2, cont_toks.unsqueeze(-1)).squeeze(
                    -1
                )  # [1, seq]

                # Answer: (log prob, is-exact-match)
                answer = (float(logits.sum()), bool(max_equal))

                # partial caching
                if cache_key is not None:
                    self.cache_hook.add_partial("loglikelihood", cache_key, answer)

                res.append(answer)

        return re_ord.get_original(res)

    def greedy_until(self, requests):
        # TODO: implement fully general `until` that handles until that are
        #       multiple tokens or that span multiple tokens correctly

        # TODO: extract to TokenizedLM?
        res = []

        def _collate(x):
            toks = self.tok_encode(x[0])
            return len(toks), x[0]

        re_ord = utils.Reorderer(requests, _collate)

        for context, until in tqdm(re_ord.get_reordered()):
            if isinstance(until, str):
                until = [until]

            (primary_until,) = self.tok_encode(until[0])

            context_enc = torch.tensor(
                [self.tok_encode(context)[self.max_gen_toks - self.max_length :]]
            ).to(self.device)

            cont = self._model_generate(
                context_enc, context_enc.shape[1] + self.max_gen_toks, primary_until
            )

            s = self.tok_decode(cont[0].tolist()[context_enc.shape[1] :])

            for term in until:
                s = s.split(term)[0]

            # partial caching
            self.cache_hook.add_partial("greedy_until", (context, until), s)

            res.append(s)

        return re_ord.get_original(res)


class Task(abc.ABC):
    """A task represents an entire benchmark including its dataset, problems,
    answers, and evaluation methods. See BoolQ for a simple example implementation

    A `doc` can be any python object which represents one instance of evaluation.
    This is usually a dictionary e.g.
        {"question": ..., "answer": ...} or
        {"question": ..., question, answer)
    """

    # The name of the `Task` benchmark as denoted in the HuggingFace datasets Hub
    # or a path to a custom `datasets` loading script.
    DATASET_PATH: str = None

    # The name of a subset within `DATASET_PATH`.
    DATASET_NAME: str = None

    def __init__(self, data_dir=None, cache_dir=None, download_mode=None):
        """
        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.download(data_dir, cache_dir, download_mode)
        self._training_docs = None
        self._validation_docs = None
        self._fewshot_docs = None

    def download(self, data_dir=None, cache_dir=None, download_mode=None):
        """Downloads and returns the task dataset.
        Override this method to download the dataset from a custom API.

        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.dataset = datasets.load_dataset(
            path=self.DATASET_PATH,
            name=self.DATASET_NAME,
            data_dir=data_dir,
            cache_dir=cache_dir,
            download_mode=download_mode,
        )

    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return False

    @abstractmethod
    def has_training_docs(self):
        """Whether the task has a training set"""
        pass

    @abstractmethod
    def has_validation_docs(self):
        """Whether the task has a validation set"""
        pass

    @abstractmethod
    def has_test_docs(self):
        """Whether the task has a test set"""
        pass

    def training_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def validation_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def test_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def _process_doc(self, doc):
        """
        Override this to process (detokenize, strip, replace, etc.) individual
        documents. This can be used in a map over documents of a data split.
        E.g. `map(self._process_doc, self.dataset["validation"])`

        :return: dict
            The processed version of the specified `doc`.
        """
        return doc

    def fewshot_examples(self, k, rnd):
        if self._training_docs is None:
            self._training_docs = list(self.training_docs())

        return rnd.sample(self._training_docs, k)

    def doc_to_decontamination_query(self, doc):
        print(
            "Override doc_to_decontamination_query with document specific decontamination query."
        )
        assert False

    @abstractmethod
    def doc_to_text(self, doc):
        pass

    @abstractmethod
    def doc_to_target(self, doc):
        pass

    def get_dataloader(self, tokenizer, split='train', batch_size=1):
        pass

    @abstractmethod
    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        pass

    @abstractmethod
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        pass

    @abstractmethod
    def aggregation(self):
        """
        :returns: {str: [metric_score] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metric scores
        """
        pass

    @abstractmethod
    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        pass

    def fewshot_description(self):
        import warnings

        warnings.warn(
            "`fewshot_description` will be removed in futures versions. Pass "
            "any custom descriptions to the `evaluate` function instead.",
            DeprecationWarning,
        )
        return ""

    @utils.positional_deprecated
    def fewshot_context(
        self, doc, num_fewshot, provide_description=None, rnd=random, description=None
    ):
        """Returns a fewshot context string that is made up of a prepended description
        (if provided), the `num_fewshot` number of examples, and an appended prompt example.

        :param doc: str
            The document as returned from training_docs, validation_docs, or test_docs.
        :param num_fewshot: int
            The number of fewshot examples to provide in the returned context string.
        :param provide_description: bool
            Not implemented, and this option is deprecated and will be removed in a future version in favor of a different description providing method
        :param rnd: random.Random
            The pseudo-random number generator used to randomly sample examples.
            WARNING: This is currently a required arg although it's optionalized with a default `None`.
        :param description: str
            The task's description that will be prepended to the fewshot examples.
        :returns: str
            The fewshot context.
        """

        assert (
            rnd is not None
        ), "A `random.Random` generator argument must be provided to `rnd`"
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        description = description + "\n\n" if description else ""

        if num_fewshot == 0:
            labeled_examples = ""
        else:
            # for sets with no training docs, draw from other set *but ensure no overlap with current doc*
            if self.has_training_docs():
                fewshotex = self.fewshot_examples(k=num_fewshot, rnd=rnd)
            else:
                if self._fewshot_docs is None:
                    self._fewshot_docs = list(
                        self.validation_docs()
                        if self.has_validation_docs()
                        else self.test_docs()
                    )

                fewshotex = rnd.sample(self._fewshot_docs, num_fewshot + 1)

                # get rid of the doc that's the one we're evaluating, if it's in the fewshot
                fewshotex = [x for x in fewshotex if x != doc][:num_fewshot]

            labeled_examples = (
                "\n\n".join(
                    [
                        self.doc_to_text(doc) + self.doc_to_target(doc)
                        for doc in fewshotex
                    ]
                )
                + "\n\n"
            )

        example = self.doc_to_text(doc)
        return description + labeled_examples + example


class MultipleChoiceTask(Task):
    def doc_to_target(self, doc):
        return " " + doc["choices"][doc["gold"]]

    def construct_requests(self, doc, ctx):
        lls = [
            rf.loglikelihood(ctx, " {}".format(choice))[0] for choice in doc["choices"]
        ]

        return lls

    def process_results(self, doc, results):
        gold = doc["gold"]

        acc = 1.0 if np.argmax(results) == gold else 0.0
        completion_len = np.array([float(len(i)) for i in doc["choices"]])
        acc_norm = 1.0 if np.argmax(results / completion_len) == gold else 0.0

        return {
            "acc": acc,
            "acc_norm": acc_norm,
        }

    def higher_is_better(self):
        return {
            "acc": True,
            "acc_norm": True,
        }

    def aggregation(self):
        return {
            "acc": mean,
            "acc_norm": mean,
        }


class PerplexityTask(Task, abc.ABC):
    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return True

    def has_training_docs(self):
        return False

    def fewshot_examples(self, k, rnd):
        assert k == 0
        return []

    def fewshot_context(
        self, doc, num_fewshot, provide_description=None, rnd=None, description=None
    ):
        assert (
            num_fewshot == 0
        ), "The number of fewshot examples must be 0 for perplexity tasks."
        assert (
            rnd is not None
        ), "A `random.Random` generator argument must be provided to `rnd`."
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        return ""

    def higher_is_better(self):
        return {
            "word_perplexity": False,
            "byte_perplexity": False,
            "bits_per_byte": False,
        }

    def doc_to_decontamination_query(self, doc):
        return doc

    def doc_to_text(self, doc):
        return ""

    def doc_to_target(self, doc):
        return doc

    def construct_requests(self, doc, ctx):
        assert not ctx
        req = rf.loglikelihood_rolling(self.doc_to_target(doc))
        return req

    def process_results(self, doc, results):
        (loglikelihood,) = results
        words = self.count_words(doc)
        bytes_ = self.count_bytes(doc)
        return {
            "word_perplexity": (loglikelihood, words),
            "byte_perplexity": (loglikelihood, bytes_),
            "bits_per_byte": (loglikelihood, bytes_),
        }

    def aggregation(self):
        return {
            "word_perplexity": weighted_perplexity,
            "byte_perplexity": weighted_perplexity,
            "bits_per_byte": bits_per_byte,
        }

    @classmethod
    def count_bytes(cls, doc):
        return len(doc.encode("utf-8"))

    @classmethod
    def count_words(cls, doc):
        """Downstream tasks with custom word boundaries should override this!"""
        return len(re.split(r"\s+", doc))


def hash_args(attr, args):
    dat = json.dumps([attr] + list(args))
    return hashlib.sha256(dat.encode("utf-8")).hexdigest()


class CacheHook:
    def __init__(self, cachinglm):
        if cachinglm is None:
            self.dbdict = None
            return

        self.dbdict = cachinglm.dbdict

    def add_partial(self, attr, req, res):
        if self.dbdict is None:
            return
        hsh = hash_args(attr, req)
        self.dbdict[hsh] = res


class CachingLM:
    def __init__(self, lm, cache_db):
        """LM wrapper that returns cached results if they exist, and uses the underlying LM if not.

        :param lm: LM
            Underlying LM
        :param cache_db: str
            Path to cache db
        """
        self.lm = lm
        self.cache_db = cache_db
        if os.path.dirname(cache_db):
            os.makedirs(os.path.dirname(cache_db), exist_ok=True)
        self.dbdict = SqliteDict(cache_db, autocommit=True)

        # add hook to lm
        lm.set_cache_hook(self.get_cache_hook())

    def __getattr__(self, attr):
        def fn(requests):
            res = []
            remaining_reqs = []

            # figure out which ones are cached and which ones are new
            for req in requests:
                hsh = hash_args(attr, req)
                if hsh in self.dbdict:
                    ob = self.dbdict[hsh]

                    assert ob is not None

                    res.append(ob)
                else:
                    res.append(None)
                    remaining_reqs.append(req)

            # actually run the LM on the requests that do not have cached results
            rem_res = getattr(self.lm, attr)(remaining_reqs)

            # stick the new ones back into the list and also cache any of the new ones
            resptr = 0
            for req, r in zip(remaining_reqs, rem_res):
                while res[resptr] is not None:
                    resptr += 1

                res[resptr] = r

                # caching
                hsh = hash_args(attr, req)
                self.dbdict[hsh] = r
            self.dbdict.commit()

            return res

        return fn

    def get_cache_hook(self):
        return CacheHook(self)


REQUEST_RETURN_LENGTHS = {
    "loglikelihood": 2,
    "greedy_until": None,
    "loglikelihood_rolling": None,
}


class Request:
    def __init__(self, request_type, args, index=None):
        if request_type not in REQUEST_RETURN_LENGTHS.keys():
            raise NotImplementedError(
                "The request type {} is not implemented!".format(request_type)
            )

        self.request_type = request_type
        self.args = args
        self.index = index

    def __iter__(self):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        for i in range(REQUEST_RETURN_LENGTHS[self.request_type]):
            yield Request(self.request_type, self.args, i)

    def __getitem__(self, i):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        return Request(self.request_type, self.args, i)

    def __eq__(self, other):
        return (
            self.request_type == other.request_type
            and self.args == other.args
            and self.index == other.index
        )

    def __repr__(self):
        return f"Req_{self.request_type}{self.args}[{self.index}]\n"


class RequestFactory:
    def __getattr__(self, attr):
        def fn(*args):
            return Request(attr, args)

        return fn


rf = RequestFactory()
